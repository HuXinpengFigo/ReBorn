---
title: 后端面经笔记-操作系统
date: 2022-03-26 10:58:45
index_img: /img/Backend-solution.webp
banner_img: /img/5-Backend-Solutions-for-Web-and-Mobile-Applications-to-Try-Firebase-Alternatives.webp
tags: [C++,面经]
categories: 实习
---

### 操作系统中的中断

> 中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。中断一般**三类**:
>
> 一种是由CPU外部引起的，如I/O中断、时钟中断;
>
> 一种是来自CPU内部事件或程序执行中引起的中断 (例如程序非法操作，地址越界、浮点溢出);
>
> 最后后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，**中断响应**由**硬件**实施，**中断处理**主要由**软件**实施。

## 进程与线程

对于有线程系统：

- 进程是**资源分配**的独立单位
- 线程是**资源调度**的独立单位

对于无线程系统：

- 进程是**资源调度、分配**的独立单位

### 进程

> 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

### 线程

> 线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。

### 协程

> 协程与子例程一样，协程（coroutine）也是一种程序组件。一个程序可以包含多个协程，可以对比与一个进程包含多个线程。
>
> 协程和线程区别：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。

### 程序与进程与线程的关系与区别

[![这里写图片描述](https://www.figohxp.top/img/70.png)](https://www.figohxp.top/img/70.png)

> - 地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间;因此线程可以读写同样的数据结构和变量，便于线程之间的通信。相反，进程间通信（IPC）很困难且消耗更多资源。
> - 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源。
> - 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元。
> - 二者均可并发执行。
> - 进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束。
> - 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志

### **进程**之间的通信方式以及优缺

#### 管道（PIPE）

> **有名管道（命名管道FIFO）**：一种半双工的通信方式，它允许无亲缘关系进程间的通信
>
> * 优点：可以实现任意关系的进程间的通信
>
> * 缺点：
>   * 长期存于系统中，使用不当容易出错
>   * 缓冲区有限
>
> **无名管道**：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（**父子进程**）
>
> * 优点：简单方便
>
> * 缺点：
>   * 局限于单向通信
>   * 只能创建在它的进程以及其有亲缘关系的进程之间
>   * 缓冲区有限

#### 信号量（Semaphore）

> * 优点：用于实现进程间的互斥与同步
>   * 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
>   * 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
>   * 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
>   * 支持信号量组。
>
> * 缺点：信号量有限

#### 信号（Signal）

> 一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
>
> * 信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式
>
> * 信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。
>
> * 如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被 取消时才被传递给进程。

　　**SIGINT**：ctrl+c 终止信号

　　SIGQUIT：ctrl+\ 终止信号

　　SIGTSTP:ctrl+z 暂停信号

　　SIGALRM：闹钟信号 收到此信号后定时结束，结束进程

　　SIGCHLD：子进程状态改变，父进程收到信号

　　SIGKILL：杀死信号

#### 消息队列（Message Queue）

> 是消息的链表，存放在内核中并由消息队列标识符（队列ID）标识。
>
> * 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
> * 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合

### 共享内存（Shared Memory）

> 映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。
>
> 
>
> * 优点：无须复制，快捷，信息量大
>   * 共享内存是最快的一种IPC，因为进程是直接对内存进行存取
>   * 因为多个进程可以同时操作，所以需要进行同步
>   * 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问
> * 缺点：
>   * 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题
>   * 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信

**系统IPC**（包括消息队列、信号量、信号、共享内存等）

#### 套接字（Socket）

> 可用于不同计算机间的进程通信
>
> 优点：
>
> * 传输数据为字节级，传输数据可自定义，**数据量小效率高**
> * 传输数据时间短，性能高
> * 适合于**客户端和服务器端之间信息实时交互**
> * 可以**加密**,数据安全性强
>
> 缺点：需对传输的数据进行解析，转化成应用级的数据。

### **线程**之间的通信方式

#### 锁机制

> 包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）

- - **读写锁**（reader-writer      lock）：允许多个线程同时读共享数据，而对写操作是互斥的。
  - **互斥锁/量**（mutex）：提供了以排他方式防止数据结构被并发修改的方法。
  - **自旋锁**（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。
  - **条件变量**（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

**互斥锁**，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下：

pthread_mutex_init:初始化互斥锁

pthread_mutex_destroy：销毁互斥锁

pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock调用将阻塞，直到该互斥锁的占有者将其解锁。

pthread_mutex_unlock:以一个原子操作的方式给一个互斥锁解锁。

 

**条件锁**，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用 signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下：

pthread_cond_init:初始化条件变量

pthread_cond_destroy：销毁条件变量

pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。

pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。



### **信号量机制**(Semaphore)

* 无名线程信号量

* 命名线程信号量

> 信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作：
>
> **P(SV)**:如果信号量SV大于0，将它减一；如果SV值为0，则挂起该线程。
>
> **V(SV)**：如果有其他进程因为等待SV而挂起，则唤醒，然后将SV+1；否则直接将SV+1。
>
> 其系统调用为：
>
> **sem_wait**（sem_t *sem）：以原子操作的方式将信号量-1，如果信号量值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。
>
> **sem_post**（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。

### **信号机制**(Signal)

> 类似进程间的信号处理。

### **屏障**（barrier）

> 屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。

线程间的通信目的是用于**线程同步**，所以线程**没有**像进程通信中的用于**数据交换**的通信机制

### **线程间通信**的方式

线程间的通信方式包括**临界区、互斥量、信号量、条件变量、读写锁**：

> **临界区**：每个线程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个线程使用的共享资源）。每次只准许一个线程进入临界区，进入后不允许其他线程进入。不论是硬件临界资源，还是软件临界资源，多个线程必须互斥地对它进行访问。
>
> **互斥量**：采用互斥对象机制，只有拥有互斥对象的线程才可以访问。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
>
> **信号量**：计数器，允许多个线程同时访问同一个资源。
>
> **条件变量**：通过条件变量通知操作的方式来保持多线程同步。
>
> **读写锁**：读写锁与互斥量类似。但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高。
>
> （1） 读写锁区分读者和写者，而互斥锁不区分
>
> （2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。

### **线程同步**方式

线程间的同步方式包括**互斥锁、信号量、条件变量、读写锁**：`除了临界区`

### **进程**之间私有和共享的资源

- 私有：**地址空间、堆、全局变量、栈、寄存器 5**
- 共享：代码段，公共数据，进程目录，进程 ID 4

### **线程**之间私有和共享的资源

- 私有：**线程栈，寄存器，程序计数器 3**
- 共享：堆，地址空间，全局变量，静态变量 4

### **多进程与多线程间的对比、优劣与选择**

#### **对比**

| **对比维度**   | **多进程**                                                   | **多线程**                                                   | **总结** |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 数据共享、同步 | 数据共享复杂，需要用 IPC；数据是分开的，**同步**简单         | 因为共享进程数据，数据**共享**简单，但也是因为这个原因导致同步复杂 | 各有优势 |
| 内存、CPU      | 占用**内存多**，**切换复杂，CPU 利用率低**                   | 占用内存少，切换简单，CPU 利用率高                           | 线程占优 |
| 创建销毁、切换 | **创建销毁、切换复杂，速度慢**                               | 创建销毁、切换简单，速度很快                                 | 线程占优 |
| 编程、调试     | **编程简单，调试简单**                                       | 编程复杂，调试复杂                                           | 进程占优 |
| 可靠性         | **进程间不会互相影响**                                       | 一个线程挂掉将导致整个进程挂掉                               | 进程占优 |
| 分布式         | 适应于**多核、多机分布式**；如果一台机器不够，扩展到多台机器比较简单 | 适应于**多核分布式**                                         | 进程占优 |

#### **优劣**

| **优劣** | **多进程**                               | **多线程**                               |
| -------- | ---------------------------------------- | ---------------------------------------- |
| 优点     | 编程、调试简单，可靠性较高               | 创建、销毁、切换速度快，内存、资源占用小 |
| 缺点     | 创建、销毁、切换速度慢，内存、资源占用大 | 编程、调试复杂，可靠性较差               |

#### 如何**选择**

- 需要**频繁创建销毁**的优先用**线程**
- 需要进行**大量计算**的优先使用**线程**
- **强相关的处理**用线程，弱相关的处理用**进程**
- 可能要扩展到多机分布的用进程，**多核分布**的用**线程**
- 都满足需求的情况下，用你最熟悉、最拿手的方式

### 有了进程，为什么还要有线程

#### 线程产生的原因

> 进程可以使多个程序能并发执行，以**提高资源的利用率和系统的吞吐量**；但具有一些缺点：
>
> **进程在同一时间只能干一件事**
>
> 进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。
>
>  
>
> 因此，操作系统引入了比进程粒度更小的**线程**，作为并发执行的基本单位，从而**减少程序在并发执行时所付出的时空开销，提高并发性**。和进程相比，线程的优势如下：
>
> 
>
> 从**资源**上来讲，线程是一种非常"节俭"的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。
>
> 从**切换效率**上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。
>
> 从**通信机制**上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。
>
> 
>
> 除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点：
>
> 1、使**多CPU系统更加有效**。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。
>
> 2、**改善程序结构**。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。

### 单核机器上写多线程程序，是否需要考虑加锁

> **在单核机器上写多线程程序，仍然需要线程锁**。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，**不使用线程锁的前提下，可能会导致共享数据修改引起冲突。**

### 多进程和多线程的使用场景

> **多进程**模型，适用于CPU密集型和多机分布式场景中，易于多机扩展。
>
> **多线程**模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时也适用于单机多核分布式场景。

### 游戏服务器应该为每个用户开辟一个线程还是一个进程

> 游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程。

### 请问线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的

> **线程在切换的过程中需要保存当前线程Id****、线程状态、堆栈、寄存器状态****等信息**。
>
> 其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：
>
> **SP**: **堆栈指针**，指向当前栈的栈顶地址
>
> **PC: ** **程序计数器**，存储下一条将要执行的指令
>
> **EAX:** **累加寄存器**，用于加法乘法的缺省寄存器

### 并发(concurrency)和并行(parallelism)

> **并发（concurrency）**：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。
>
> **并行（parallelism）**：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。

### 进程同步的方式

> **信号量**semaphore：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。
>
> **管道**：一个进程通过调用管程的一个过程进入管程。在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。
>
> **消息队列**：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。

### 什么是孤儿进程，什么是僵尸进程，如何解决僵尸进程

> **孤儿进程**：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完整状态收集工作。
>
> **僵尸进程**：是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。
>
>  
>
> 如何解决僵尸进程：
>
> （1）一般，为了防止产生僵尸进程，在fork子进程之后我们都要及时使用wait系统调用；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。
>
> （2）使用kill命令。

### 什么是守护进程，如何实现

> **守护进程**：守护进程是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些系统级别任务。
>
>  
>
> 如何实现：
>
> （1）创建子进程，终止父进程。方法是调用fork() 产生一个子进程，然后使父进程退出。
>
> （2）调用setsid() 创建一个新会话。
>
> （3）将当前目录更改为根目录。使用fork() 创建的子进程也继承了父进程的当前工作目录。
>
> （4）重设文件权限掩码。文件权限掩码是指屏蔽掉文件权限中的对应位。
>
> （5）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。

## 进程调度算法

> **先来先服务调度算法**：每次调度都是从后备作业（进程）队列中选择一个或多个最先进入该队列的作业（进程），将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。
>
> **短作业(** **进程 )** **优先调度算法**：短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业（进程），将它们调入内存运行。
>
> **高优先级优先调度算法**：当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程
>
> **时间片轮转法**：每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。
>
> **多级反馈队列调度算法**：综合前面多种调度算法。

### 这些调度算法中，有抢占式和非抢占式的区别

> 非抢占式优先权算法：系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。
>
> 抢占式优先权调度算法：系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi>Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。
>
>  
>
> **区别**：
>
> 非抢占式（Nonpreemptive）：让进程运行直到结束或阻塞的调度方式，容易实现，**适合专用系统**，不适合通用系统。
>
> 抢占式：允许将逻辑上可继续运行的在运行过程暂停的调度方式可防止单一进程长时间独占，**CPU** **系统开销大**（降低途径：硬件实现进程切换，或扩充主存以贮存大部分程序）

### 进程有多少种状态

> **创建、就绪、执行、阻塞、终止**。一个进程创建后，被放入队列处于就绪状态，等待操作系统调度执行，执行过程中可能切换到阻塞状态（并发），任务完成后，进程销毁终止。
>
>  
>
> **创建状态** 一个应用程序从系统上启动，首先就是进入创建状态，需要获取系统资源创建进程管理块（PCB：Process Control Block）完成资源分配。
>
> **就绪状态** 在创建状态完成之后，进程已经准备好，处于就绪状态，但是还未获得处理器资源，无法运行。
>
> **运行状态** 获取处理器资源，被系统调度，当具有时间片开始进入运行状态。如果进程的时间片用完了就进入就绪状态。
>
> **阻塞状态** 在运行状态期间，如果进行了阻塞的操作，如耗时的I/O操作，此时进程暂时无法操作就进入到了阻塞状态，在这些操作完成后就进入就绪状态。等待再次获取处理器资源，被系统调度，当具有时间片就进入运行状态。
>
> **终止状态** 进程结束或者被系统终止，进入终止状态
>
>  
>
> 相互转换如图：
>
> ![image-20220329123616157](/img/image-20220329123616157.png)

## **Linux** **内核的同步方式**

### **原因**

> 在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。

### **同步方式 9种**

- **原子操作**
- **信号量（ semaphore** **）**
- **读写信号量（ rw_semaphore** **）**
- **自旋锁（ spinlock** **）**
- **大内核锁（ BKL** **，Big Kernel Lock** **）**
- **读写锁（ rwlock** **）**
- **大读者锁（ brlock-Big Reader Lock** **）**
- **读-** **拷贝修改( RCU** **，Read-Copy Update )**
- **顺序锁（ seqlock** **）**

### **Linux虚拟地址空间**

> 为了防止**不同进程**同一时刻在物理内存中运行而对**物理内存**的争夺和践踏，采用了虚拟内存。
>
> 
>
> 虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。
>
> 
>
> **所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上**。 
>
> 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。
>
> 
>
> **请求分页**系统、**请求分段**系统和**请求段页式**系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。

### 为什么要用虚拟内存

> 因为早期的内存分配方法存在以下问题：
>
> （1）进程地址空间不隔离。会导致数据被随意修改。
>
> （2）内存使用效率低。
>
> （3）程序运行的地址不确定。操作系统随机为进程分配内存空间，所以程序运行的地址是不确定的。

### 虚拟内存的好处

> 1.扩大地址空间；
>
> 2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。
>
> 3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。
>
> 4.当进程通信时，可采用虚存共享的方式实现。
>
> 5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存
>
> 6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高
>
> 7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片

### 虚拟内存的代价

> 1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存
>
> 2.虚拟地址到物理地址的转换，增加了指令的执行时间。
>
> 3.页面的换入换出需要磁盘I/O，这是很耗时的
>
> 4.如果一页中只有一部分数据，会浪费内存。

## **死锁**

### 死锁原因

