---
title: 后端面经笔记--C++基础与并发
date: 2022-03-05 17:32:36
index_img: /img/Backend-solution.webp
banner_img: /img/5-Backend-Solutions-for-Web-and-Mobile-Applications-to-Try-Firebase-Alternatives.webp
tags: [C++,面经]
categories: 实习

---

## C++ 基础

### 面向对象三大特性：封装、继承、多态如何在C++中体现

#### 封装

> 体现在C++中的类（**Class**），它所封装的是自己的属性和方法，内部属性和方法分public、protected、private。

#### 继承

> 继承就是新类从已有类那里得到已有的特性。 类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，子类继承基类后，可以创建子类对象来调用基类函数，变量等。
>
> * **单一继承：**继承一个父类，这种继承称为单一继承，一般情况尽量使用单一继承，使用多重继承容易造成混乱易出问题。
> * **多重继承：**继承多个父类，类与类之间要用逗号隔开，类名之前要有继承权限，假使两个或两个基类都有某变量或函数，在子类中调用时需要加类名限定符如c.a::i = 1；
> * **菱形继承：**多重继承掺杂隔代继承1-n-1模式，此时需要用到虚继承，例如 B，C虚拟继承于A，D再多重继承B，C，否则会出错。
> * **继承权限：**继承方式规定了如何访问继承的基类的成员。继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限。
> * **继承权限：**子类继承基类除构造和析构函数以外的所有成员。

#### 多态

> 可以简单概括为“一个接口，多种方法”，即用的是同一个接口，但是效果各不相同，多态有两种形式的多态，一种是'静态多态'，一种是'动态多态'。

##### 动态多态

> 是指在程序运行时才能确定函数和实现的链接，此时才能确定调用哪个函数，运行期多态的实现依赖于**虚函数**（用'virtual'关键字修饰的函数）机制。将函数声明为虚函数会降低效率，一般函数在编译期其相对地址是确定的。
>
> * **重写**翻译自override，是指**派生类中**存在重新定义的函数。其**函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致**。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。**重写的基类中被重写的函数必须有virtual修饰。**
>
> * **虚函数表**：虚表指明了实际所应调用的函数基类有一个虚表，可以被子类继承，(当类中有虚函数时该类才会有虚表,该类的对象才有虚指针，子类继承时也会继承基类的虚表)，子类如果重写了基类的某虚函数，那么子类继承于基类的虚表中该虚函数的地址也会相应改变，指向子类自身的该虚函数实现，如果子类有自己的虚函数，那么子类的虚表中就会增加该项，编译器为每个类对象定义了一个**虚指针**，来定位虚表。**在构造函数中进行虚表的创建和虚指针的初始化**。

##### 静态多态

> 是在编译期就把函数链接起来，此时即可确定调用哪个函数或模板，静态多态是由**模板**和**重载**实现的，在**宏多态**中，是通过定义变量，编译时直接把变量替换，实现宏多态。
>
> * **重载**从overload翻译过来，是指同一可访问区内被声明的**几个具有不同参数列表（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。**
>   * *优点：** 带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的武器； 在编译期完成多态，提高运行期效率； 具有很强的适配性和松耦合性，（耦合性指的是两个功能模块之间的依赖关系）
>   * **缺点：** 程序可读性降低，代码调试带来困难；无法实现模板的分离编译，当工程很大时，编译时间不可小觑 ；无法处理异质对象集合

#### 隐藏，与重载、重写的区别

> **隐藏**是指**派生类的函数屏蔽了与其同名的基类函数**。注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。

##### 重载与重写的区别

> * 范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
> * 参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
> * virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。

##### **隐藏和重写，重载的区别**

> * 与重载范围不同：隐藏函数和被隐藏函数在不同类中。
> * 参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。

### 深拷贝浅拷贝

#### 浅拷贝

> 对于基本的数据类型和简单对象，他们之间的拷贝非常简单，就是按位复制内存，这种默认的拷贝行为就是浅拷贝，这和memcpy()函数的调用效果非常类似。

```c++
int a=10;
int b=a;
```

#### 深拷贝

> 将对象所持有的其他资源一并拷贝的行为叫做深拷贝，必须显示的定义拷贝构造函数才能达到深拷贝的目的。深拷贝会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来，这样能保证原有对象和新对象所持有的动态内存都是相互独立的，更改一个对象的数据不会影响另一个对象。
>
> 深拷贝的例子比比皆是，标准模板库中的string、vector、stack、map等都是必须使用深拷贝的。

#### 怎么判断是深拷贝还是浅拷贝

> * 当一个类拥有指针类型的成员变量时，那么绝大部份情况下就需要深拷贝。因为只有这样才能将指针指向的内容再复制一份出来，让原有对象和新对象相互独立，彼此不影响。
>
> * 如果创建对象时需要进行一些预处理工作，比如统计创建过的对象数目、记录对象创建的时间等，这时就必须使用深拷贝。

### C++ 11特性

> [C++11 特性相关知识](https://www.nowcoder.com/discuss/840768?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=D68F5CC4A5088E8311C5FF791A330F3B-1646540556641)

	## 容器



### **list、vector、map、set区别**

#### **list**

> 封装链表，以链表形式实现，不支持[]运算符。
>
> 对随机访问的速度很慢(需要遍历整个链表)，插入数据很快(不需要拷贝和移动数据，只需改变指针的指向)。
>
> 新添加的元素，list可以任意加入。
>
> * 使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。

#### **vector**

> 封装数组，使用连续内存存储，支持[]运算符。
>
> 对随机访问的速度很快，对头插元素速度很慢，尾插元素速度很快
>
> 新添加的元素，vector有一套算法。

#### **map**

> 采用平衡检索二叉树:红黑树
>
> 存储结构为键值对<key,value>
>
> * 使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。

#### **set**

> 采用平衡检索二叉树:红黑树
>
> set中不包含重复的数据
>
> * 使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。

#### **Hash_Map**

> 采用hash算法加快查找过程，但需要更多内存存放hash桶元素，是一种采用空间换取时间的策略。

#### **stack**

> stack堆栈容器，是一种“先进后出”的容器

参考：[c++容器list、vector、map、set区别与用法详解](https://www.jb51.net/article/187294.htm)

## 并发

### 进程

> 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

### 线程

> 线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。

### 协程

> 协程与子例程一样，协程（coroutine）也是一种程序组件。一个程序可以包含多个协程，可以对比与一个进程包含多个线程。
>
> 协程和线程区别：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。

### 程序与进程与线程的关系与区别

![这里写图片描述](/img/70.png)

> * 地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间;因此线程可以读写同样的数据结构和变量，便于线程之间的通信。相反，进程间通信（IPC）很困难且消耗更多资源。 
> * 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源。
> * 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元。
> * 二者均可并发执行。
> * 进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束。
> * 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。

参考：[进程、线程和协程的理解](https://www.cnblogs.com/guolei2570/p/8810536.html)

## Unity 3D

### Unity 生命周期

> Awake ->OnEable -> Start -> FixedUpdate-> Update -> LateUpdate ->OnGUI -> OnDisable ->OnDestroy

> **1.Awake：**
>  用于在游戏开始之前初始化变量或游戏状态。在脚本整个生命周期内它仅被调用一次.Awake在所有对象被初始化之后调用，所以你可以安全的与其他对象对话或用诸如GameObject.FindWithTag()这样的函数搜索它们。每个游戏物体上的Awake以随机的顺序被调用。因此，你应该用Awake来设置脚本间的引用，并用Start来传递信息Awake总是在Start之前被调用。它不能用来执行协同程序。
>  **2.Start**：
>  仅在Update函数第一次被调用前调用。Start在behaviour的生命周期中只被调用一次。它和Awake的不同是Start只在脚本实例被启用时调用。你可以按需调整延迟初始化代码。Awake总是在Start之前执行。这允许你协调初始化顺序。在所有脚本实例中，Start函数总是在Awake函数之后调用。
>  **3.FixedUpdate**：
>  固定帧更新，在Unity导航菜单栏中，点击“Edit”–>“Project Setting”–>“Time”菜单项后，右侧的Inspector视图将弹出时间管理器，其中“Fixed Timestep”选项用于设置FixedUpdate()的更新频率，更新频率默认为0.02s。
>  **4.Update：**
>  正常帧更新，用于更新逻辑。每一帧都执行，处理Rigidbody时，需要用FixedUpdate代替Update。例如:给刚体加一个作用力时，你必须应用作用力在FixedUpdate里的固定帧，而不是Update中的帧。(两者帧长不同)FixedUpdate，每固定帧绘制时执行一次，和update不同的是FixedUpdate是渲染帧执行，如果你的渲染效率低下的时候FixedUpdate调用次数就会跟着下降。FixedUpdate比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update就比较适合做控制。
>  **5.LateUpdate**：
>  在所有Update函数调用后被调用，和fixedupdate一样都是每一帧都被调用执行，这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。LateUpdate,在每帧Update执行完毕调用，他是在所有update结束后才调用，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是在所有update操作完才跟进摄像机，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。
>  **6.OnGUI：**
>  在渲染和处理GUI事件时调用。比如：你画一个button或label时常常用到它。这意味着OnGUI也是每帧执行一次。
>  **7.Reset**：
>  在用户点击检视面板的Reset按钮或者首次添加该组件时被调用。此函数只在编辑模式下被调用。Reset最常用于在检视面板中给定一个默认值。
>  **8.OnDisable**：
>  当物体被销毁时 OnDisable将被调用，并且可用于任意清理代码。脚本被卸载时，OnDisable将被调用，OnEnable在脚本被载入后调用。注意： OnDisable不能用于协同程序。
>  **9.OnDestroy**：
>  当MonoBehaviour将被销毁时，这个函数被调用。OnDestroy只会在预先已经被激活的游戏物体上被调用。注意：OnDestroy也不能用于协同程序。

![img](/img/webp.png)



![img](/img/webp2.png)

### C# C++ 区别

> 1. C#与Java类似，编译后得到的还不是机器代码，而是运行在**虚拟机**中的元指令。它对安全性做了更多的考虑，没有指针，不能直接操作内存，自动实现内存管理。C++中的指针在带来强大的灵活性和高效的同时，也带了不少使用上的难题，C++程序中的绝大多数问题都来源于指针的不正确使用，C#出于软件安全性的考虑和语言易用性的考虑没有指针。
>
>    C#中实现**自动垃圾回收**，通过new在堆中创建对象，当对该对象的引用计数为0时回收内存。类有构造函数而没有析够函数。
>
>    C#**没有指针**这个概念，只有引用和数值之分。int等内部数据类型和struct定义的类型是数据类型，拷贝时做深度拷贝；而string和用class定义的类型是引用类型，拷贝时做浅拷贝——与深度拷贝对应，它通过引用计数来实现对象和内存管理。
>
>    C++中用指针能够轻易实现的功能，C#需要引进许多额外的机制。比如C++的函数指针，在C#中称之为delegate。C#中的**参数传递**，分为**传值**和**传址**两种，传址时需要加**ref**或者**out**(传回改变)关键字。
>
>    C#中的**const**与C++中的有所不同，它指**编译期常量**，而**运行期**间的常量要用**readonly**来指定。
>
> 2. C#的OO特性更为彻底，**一切皆对象**，不存在独立的函数，程序的入口Main()函数是某个对象的public static成员函数。
>
>    **所有对象都是由Object派生而来**，包括内部数据类型int,float,string等，它们只是System.int32等的别名而已。C#中**没有模板**，通过将参数设置为Object类型来实现类似的功能，它的downcast类似于C++中的dynamic_cast操作符。
>
>    C#**没有头文件**，变量、函数和类没有定义和申明的区别，都在一起。只能通过设计抽象类的方式实现代码分离。C++在这方面虽然做得还不够完美，但比C#强不少。
>
>    C#中有**属性(Properties)**和**索引(Index)**。属性类似于C++中的那些GetValue()和SetValue()成员函数，只是使用上有些差别。索引类似于C++中的重载操作符[]。
>
>    C#中在类中的成员变量声明处即可初始化，而C++中不行，两者都可以在构造函数中初始化成员变量。C#中的**静态成员变量**可以在**静态构造函数中初始化**，而静态构造函数是在该类的第一次使用时调用，而C++中是在编译单元载入时初始化静态成员变量。
>
> 3. C#的语法中多了**foreach(typevinlist)statement;**而C++中需要用C++标准库的函数实现类似功能。

