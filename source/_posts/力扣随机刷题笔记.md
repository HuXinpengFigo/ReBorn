---
title: 力扣随机刷题笔记
date: 2022-03-25 15:49:57
index_img: /img/LeetCode_Sharing.png
banner_img: /img/h4ear4i3g4q7r04utgpm.png
tags: [C++,LeetCode]
categories: 实习
---

### [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

#### 描述

> 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>
> 假设你总是可以到达数组的最后一个位置。
>

示例 1:

输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。

从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:

输入: nums = [2,3,0,1,4]
输出: 2




提示:

1 <= nums.length <= 104
0 <= nums[i] <= 1000

#### 思路

> 贪心思想，一直记录在某个阶段中能够达到的最远距离。
>
> 我们需要遍历整个数组，在遍历的同时，记录下当前阶段中能走最远距离在哪。在到达这个最远距离之前，这个阶段都算作为一步之内。
>
> 维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界（到这个阶段能走到的最远距离）并将跳跃次数增加 1。
>
> 最终最远距离大于等于数组长度减一时，说明我们step数量足够了（此时step也要加一）。

#### 代码

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int end = 0, current = 0, n = nums.size()-1;
        int step = 0, maxPos = 0;
        while ( end < n ) {
            maxPos = max(maxPos, current + nums[current]); //每次都看看在当前位置下能走的最远值能不能更新
            if ( current == end) { //到达边界
                end = maxPos;
                step++;
            }
            current++;
        }
        return step;
    }
};
```

