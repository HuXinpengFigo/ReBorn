---
title: 后端面经笔记--消息队列与数据库
date: 2022-03-06 22:22:05
index_img: /img/5-Backend-Solutions-for-Web-and-Mobile-Applications-to-Try-Firebase-Alternatives.webp
banner_img: /img/Backend-solution.webp
tags: [C++,面经]
categories: 实习
---

## 消息队列

### 消息队列

> **消息队列**是分布式应用间交换信息的重要组件，消息队列可驻留在内存或磁盘上, 队列可以存储消息直到它们被应用程序读走。
>
> 现在比较常见的消息队列产品主要有**ActiveMQ**、**RabbitMQ**、**ZeroMQ**、**Kafka**、**RocketMQ**等。

### RabbitMQ

> RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。
>
> 用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。
>
> 消息队列的使用过程，如下：
>
> 1. 客户端连接到消息队列服务器，打开一个channel。
> 2. 客户端声明一个exchange，并设置相关属性。
> 3. 客户端声明一个queue，并设置相关属性。
> 4. 客户端使用routing key，在exchange和queue之间建立好绑定关系。
> 5. 客户端投递消息到exchange。
>
> exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。

### Kafka

> Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。
>
> * 通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。（文件追加的方式写入数据，过期的数据定期删除）
> * 高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息
> * 支持通过Kafka服务器和消费机集群来分区消息
> * 支持Hadoop并行数据加载

### 消息队列中点对点模型与发布/订阅模式

![img](/img/20150817113531436.png)

生产者发送一条消息到queue，只有**一个**消费者能收到。

![img](/img/20150817113626248.png)

发布者发送到topic的消息，只有**订阅了topic的订阅者**才会收到消息。

## MySQL

### SQL语句在MySQL是如何执行的

![img](/img/1365470-20200330140529330-934488719.png)

大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。

- Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
- 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。

#### 查询缓存

由于表经常更新，查询缓存的失效频繁，查询缓存往往利大于弊。，MySQL 8.0 版本开始直接将查询缓存的整块功能删掉了。

#### 优化器

经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。

优化器是**在表里面有多个索引的时候，决定使用哪个索引**；或者在一个语句**有多表关联（join）的时候，决定各个表的连接顺序**。比如你执行下面这样的语句，这个语句是执行两个表的 join：



```sql
mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

- 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
- 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。
  这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。

如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。

#### 执行器

开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示：



```sql
mysql> select * from T where ID=10;

ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T
```

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去**使用这个引擎提供的接口**。

比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

至此，这个语句就执行完成了.

参考：[一条SQL语句，在MySQL中是如何执行的](https://www.cnblogs.com/lfri/p/12598339.html)

### 常见存储引擎

>  存储引擎是数据库的核心，在MySQL中，存储引擎是以插件的形式运行的。支持的引擎有十几种之多，但我们实战常用到的，大概只有InnoDB、MyISAM 和 Memory 了。

#### InnoDB

> InnoDB 从 MySQL5.5（2010年） 版本代替 MyISAM 成为默认引擎。相比MyISAM强调性能，InnoDB 侧重于提供事务支持以及外部键等高级数据库功能。具体特点：
>
> * 支持事务。默认的事务隔离级别为可重复读（REPEATABLE-READ），通过MVCC（并发版本控制）来实现。
> * 使用的锁粒度默认为行级锁，可以支持更高的并发；当然，也支持表锁。
> * 支持外键约束；外键约束其实降低了表的查询速度，但是增加了表之间的耦合度。
> * 可以通过自动增长列，方法是auto_increment。
> * 配合一些热备工具可以支持在线热备份；
> * 在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；
> * 对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上。
> * DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
>
> InnoDB的存储表和索引有下面两种形式：
>
> - 共享表空间存储：所有的表和索引存放在同一个表空间中。
> - 多表空间存储：表结构放在.frm文件，数据和索引放在.ibd文件中。分区表的话，每个分区对应单独的.ibd文件，分区表的定义可以查看我的其他文章。使用分区表的好处在于提升查询效率。
>
> 对于InnoDB来说，最大的优势在于支持事务，当然这是以牺牲效率为代价的。

#### MyISAM

> 还有好多同学在面试回答 InnoDB 和 MyISAM 区别的时候，依然会带上 InnoDB 不支持全文检索，MyISAM 支持对 BLOB 和 TEXT 的前500个字符索引云云，那是5、6年之前的答案啦。
>
> * 不支持事务。不支持事务，像是挣脱了枷锁，在读写（Insert、select）效率上，要高于InnoDB不少。场景在：日志记录、调查统计表时，绝对值得一用。对了，不支持事务，自然就不支持锁。
>
> * 体积小，质量大。MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。同时能加载更多索引，而Innodb的索引和数据是紧密捆绑的，没有使用压缩从而会造成 Innodb 比 MyISAM 数据文件体积庞大很多。
>
>   ​	每张MyISAM表在磁盘上会对应三个文件。
>
>   ​	（1）.frm文件：存储表的定义数据
>
>   ​	（2）.MYD文件：存放表具体记录的数据
>
>   ​	（3）.MYI文件：存储索引
>
> * 常常应用部门需要我给他们定期某些表的数据，MyISAM的话很方便，只要发给他们对应那表的（frm.MYD,MYI）的文件，让他们自己在对应版本的数据库启动就行，而Innodb就需要导出.sql了，因为光给别人文件，受字典数据文件的影响，对方是无法使用的。
> * MyISAM表的select count(\*) 是非常快的；在 MyISAM 存储引擎中，把表的总行数（row）存储在磁盘上，当执行 select count(\*) from t 时，直接返回总数据。同样，当 count(*) 语句包含 where条件时，两种表的操作是一样的。
> * DELETE FROM table时，MyISAM会先将表结构备份到一张虚拟表中，然后执行drop，最后根据备份重建该表。

#### Memory

> 可以将它理解为，临时表。Memory是将数据直接存在内存中的，特别适合数据量小的表。同时为了提高数据的访问速度，每一个表实际上和一个磁盘文件关联，文件是frm。
>
> * 支持的数据类型有限制，比如：不支持TEXT和BLOB类型。对于字符串类型的数据，只支持固定长度的行，VARCHAR(64)会被自动存储为CHAR(64)类型；
> * 只支持表级锁。所以，在访问量比较大时，表级锁会成为MEMORY存储引擎的瓶颈；
> * 由于数据是存放在内存中，一旦服务器宕机，数据就会丢失；数据库主从切换的配置要设置好。
> * 查询的时候，如果有用到临时表，而且临时表中有BLOB，TEXT类型的字段，那么这个临时表就会转化为MyISAM类型的表，性能会急剧降低；
> * 默认使用hash索引。

### MySQL 索引为什么采用B+树

#### MySQL中存储索引用到的数据结构是B+树，B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。既然hash比B+树更快，为什么mysql用B+树来存储索引呢？

> 1. 从内存角度上说，数据库中的索引一般时在磁盘上，数据量大的情况可能无法一次性装入内存，B+树的设计可以允许数据分批加载。
> 2. 从业务场景上说，如果只选择一个数据那确实是hash更快，但是数据库中经常会选中多条这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。

#### 为什么不用红黑树或者二叉排序树？

> 树的查询时间跟树的高度有关，B+树是一棵多路搜索树可以降低树的高度，提高查找效率.

#### 既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？

> 这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。有序数组没法一次性加载进内存，这时候B+树的多路存储威力就出来了，可以每次加载B+树的一个结点，然后一步步往下找.

#### 在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B+树吗？

> B+树是在B树的基础上进行改造，它的数据都在叶子结点，同时叶子结点之间还加了指针形成链表。
>
> 下面是一个4路B+树，它的数据都在叶子结点，并且有链表相连。

#### 为什么B+树要这样设计？

> 这个跟它的使用场景有关，B+树在数据库的索引中用得比较多，数据库中select数据，不一定只选一条，很多时候会选中多条，比如按照id进行排序后选100条。如果是多条的话，B树需要做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。

参考：[为什么mysql索引要使用B+树，而不是B树，红黑树（B树与B+树细节）](https://segmentfault.com/a/1190000021488885)

## Redis

Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。

键的类型只能为字符串，值支持五种数据类型：字符串（Sting）、列表（List）、集合（Set）、散列表（Hash）、有序集合（ZSet）。

### 为什么Redis这么快？

> 首先，采用了**多路复用io阻塞**机制
> 然后，**数据结构简单**，操作节省时间
> 最后，**运行在内存**中，自然速度快

### Redis 优缺点

#### 优点

> * **读写性能好**，读的速度可达110000次/s，写的速度可达81000次/s。 
> * **支持数据持久化**，有AOF和RDB两中持久化方式 
> * **数据结构丰富**，支持String、List、Set、Hash等结构 
> * **支持事务**，Redis所有的操作都是原子性的，并且还支持几个操作合并后的原子性执行，原子性指操作要么成功执行，要么失败不执行，不会执行一部分。 
> * **支持主从复制**，主机可以自动将数据同步到从机，进行读写分离。

#### 缺点

> * 因为Redis是将数据存到内存中的，所以会受到内存大小的限制，不能用作海量数据的读写 
> * Redis不具备自动容错和恢复功能，主机或从机宕机会导致前端部分读写请求失败，需要重启机器或者手动切换前端的IP才能切换

### Redis为什么常常用做缓存？相比于guava有什么优势？

> 缓存的定义是访问速度比一般随机存取存储器快的一种高速存储器，而因为Redis是基于内存提供了高性能的数据存取功能，其比较显著的优势就是非常的快。
>
> 缓存可以分为**本地缓存**或者**分布式缓存**，比较常用的**guava缓存**就是一种本地缓存，其主要特点是**轻量并且快速**，生命周期随着JVM的销毁而结束，缺点是在多实例的情况下，每个实例都要自己保存一份缓存，这样会导致缓存的一致性出现问题。
>
> Redis则是分布式缓存，在多实例情况下，每个实例都共享一份缓存数据，缓存具备一致性。缺点是要保持Redis的高可用整体架构会比较复杂。

### Redis是单线程还是多线程？Redis为什么这么快？

> Redis6.0之前是**单线程**的，为什么Redis6.0之前采用单线程而不采用多线程呢？
>
> 简单来说，就是Redis官方认为没必要，单线程的Redis的瓶颈通常在**CPU的IO**，而在使用Redis时几乎不存在CPU成为瓶颈的情况。使用Redis主要的瓶颈在内存和网络，并且使用单线程也存在一些优点，比如系统的复杂度较低，可为维护性较高，避免了并发读写所带来的一系列问题。
>
> 
>
> Redis为什么这么快主要有以下几个原因：
>
> - 运行在内存中 
> - 数据结构简单 
> - 使用多路IO复用技术 
> - 单线程实现，单线程避免了线程切换、锁等造成的性能开销。

### Redis6.0之后为什么引入了多线程？

>  前面也说了Redis的瓶颈在**内存和网络**，Redis6.0引入多线程主要是为了解决**网路IO**读写这个瓶颈，**执行命令还是单线程执行的**，所以也不存在线程安全问题。
>
> 
>
> Redis6.0默认是否开启了多线程呢？
>
> 默认是没有开启的，如需开启，需要修改配置文件redis.conf：io-threads-do-reads no，no改为yes

参考：[Redis高频面试题](https://www.nowcoder.com/discuss/830731?source_id=profile_create_nctrack&channel=-1)

### Redis数据结构

Redis的常见的数据类型有S**tring、Hash、Set、List、ZSet**。还有三种不那么常见的数据类型：**Bitmap、HyperLogLog、Geospatial**。

| 数据类型 | 可以存储的值           | 操作                                                         |
| -------- | ---------------------- | ------------------------------------------------------------ |
| STRING   | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作 |
| LIST     | 列表                   | 从两端压入或者弹出元素 </br> 对单个或者多个元素进行修剪，</br> 只保留一个范围内的元素 |
| SET      | 无序集合               | 添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素 |
| HASH     | 包含键值对的无序散列表 | 添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在 |
| ZSET     | 有序集合               | 添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名 |

### Redis都可以干什么事

> * 缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；
> * 排行榜，如果使用传统的关系型数据库来做这个事儿，非常的麻烦，而利用Redis的SortSet数据结构能够非常方便搞定；
> * 计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；
> * 好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；
> * 简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；
> * Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。

### Redis不能干什么事

> 用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。
>
> 
>
> 简单总结就是数据量太大、数据访问频率非常低的业务都不适合使用Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。

![img](/img/164b614cfe3ccf53~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp.png)

![img](/img/164b614cf0440bbe~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp.png)

![img](/img/164b614cf05432fb~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp.png)

参考：[为什么要用Redis](https://juejin.cn/post/6844903641145425927)

