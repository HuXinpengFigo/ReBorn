---
title: 后端面经笔记--消息队列与数据库
date: 2022-03-06 22:22:05
index_img: /img/Backend-solution.webp
banner_img: /img/5-Backend-Solutions-for-Web-and-Mobile-Applications-to-Try-Firebase-Alternatives.webp
tags: [C++,面经]
categories: 实习
---

## 消息队列

### 消息队列

> **消息队列**是分布式应用间交换信息的重要组件，消息队列可驻留在内存或磁盘上, 队列可以存储消息直到它们被应用程序读走。
>
> 现在比较常见的消息队列产品主要有**ActiveMQ**、**RabbitMQ**、**ZeroMQ**、**Kafka**、**RocketMQ**等。

### RabbitMQ

> RabbitMQ是流行的开源消息队列系统，用erlang语言开发。RabbitMQ是AMQP（高级消息队列协议）的标准实现。
>
> 用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。
>
> 消息队列的使用过程，如下：
>
> 1. 客户端连接到消息队列服务器，打开一个channel。
> 2. 客户端声明一个exchange，并设置相关属性。
> 3. 客户端声明一个queue，并设置相关属性。
> 4. 客户端使用routing key，在exchange和queue之间建立好绑定关系。
> 5. 客户端投递消息到exchange。
>
> exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。

### Kafka

> Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。
>
> * 通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。（文件追加的方式写入数据，过期的数据定期删除）
> * 高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息
> * 支持通过Kafka服务器和消费机集群来分区消息
> * 支持Hadoop并行数据加载

### 消息队列中点对点模型与发布/订阅模式

![img](/Users/figo/fluid/themes/fluid/source/img/20150817113531436.png)

生产者发送一条消息到queue，只有**一个**消费者能收到。

![img](/Users/figo/fluid/themes/fluid/source/img/20150817113626248.png)

发布者发送到topic的消息，只有**订阅了topic的订阅者**才会收到消息。

## MySQL

### SQL语句在MySQL是如何执行的

![img](/Users/figo/fluid/themes/fluid/source/img/1365470-20200330140529330-934488719.png)

大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。

- Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
- 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine=memory, 来指定使用内存引擎创建表。

#### 查询缓存

由于表经常更新，查询缓存的失效频繁，查询缓存往往利大于弊。，MySQL 8.0 版本开始直接将查询缓存的整块功能删掉了。

#### 优化器

经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。

优化器是**在表里面有多个索引的时候，决定使用哪个索引**；或者在一个语句**有多表关联（join）的时候，决定各个表的连接顺序**。比如你执行下面这样的语句，这个语句是执行两个表的 join：



```sql
mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

- 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
- 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。
  这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。

如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。

#### 执行器

开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示：



```sql
mysql> select * from T where ID=10;

ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T
```

如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去**使用这个引擎提供的接口**。

比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：

1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

至此，这个语句就执行完成了

### 常见存储引擎

