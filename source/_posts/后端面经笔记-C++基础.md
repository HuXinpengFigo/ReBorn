---
title: 后端面经笔记--C++基础与并发
date: 2022-03-05 17:32:36
index_img: /img/Backend-solution.webp
banner_img: /img/5-Backend-Solutions-for-Web-and-Mobile-Applications-to-Try-Firebase-Alternatives.webp
tags: [C++,面经]
categories: 实习
---

## C++ 基础

### 面向对象三大特性：封装、继承、多态如何在C++中体现

#### 封装

> 体现在C++中的类（**Class**），它所封装的是自己的属性和方法，内部属性和方法分public、protected、private。

#### 继承

> 继承就是新类从已有类那里得到已有的特性。 类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，子类继承基类后，可以创建子类对象来调用基类函数，变量等。
>
> * **单一继承：**继承一个父类，这种继承称为单一继承，一般情况尽量使用单一继承，使用多重继承容易造成混乱易出问题。
> * **多重继承：**继承多个父类，类与类之间要用逗号隔开，类名之前要有继承权限，假使两个或两个基类都有某变量或函数，在子类中调用时需要加类名限定符如c.a::i = 1；
> * **菱形继承：**多重继承掺杂隔代继承1-n-1模式，此时需要用到虚继承，例如 B，C虚拟继承于A，D再多重继承B，C，否则会出错。
> * **继承权限：**继承方式规定了如何访问继承的基类的成员。继承方式指定了派生类成员以及类外对象对于从基类继承来的成员的访问权限。
> * **继承权限：**子类继承基类除构造和析构函数以外的所有成员。

#### 多态

> 可以简单概括为“一个接口，多种方法”，即用的是同一个接口，但是效果各不相同，多态有两种形式的多态，一种是'静态多态'，一种是'动态多态'。
>
> * **动态多态：**   是指在程序运行时才能确定函数和实现的链接，此时才能确定调用哪个函数，运行期多态的实现依赖于**虚函数**（用'virtual'关键字修饰的函数）机制。将函数声明为虚函数会降低效率，一般函数在编译期其相对地址是确定的。
>   * **虚函数表**：虚表指明了实际所应调用的函数基类有一个虚表，可以被子类继承，(当类中有虚函数时该类才会有虚表,该类的对象才有虚指针，子类继承时也会继承基类的虚表)，子类如果重写了基类的某虚函数，那么子类继承于基类的虚表中该虚函数的地址也会相应改变，指向子类自身的该虚函数实现，如果子类有自己的虚函数，那么子类的虚表中就会增加该项，编译器为每个类对象定义了一个**虚指针**，来定位虚表。**在构造函数中进行虚表的创建和虚指针的初始化**。
> * **静态多态：**是在编译期就把函数链接起来，此时即可确定调用哪个函数或模板，静态多态是由**模板**和**重载**实现的，在**宏多态**中，是通过定义变量，编译时直接把变量替换，实现宏多态。
>   * **优点：** 带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的武器； 在编译期完成多态，提高运行期效率； 具有很强的适配性和松耦合性，（耦合性指的是两个功能模块之间的依赖关系）
>   * **缺点：** 程序可读性降低，代码调试带来困难；无法实现模板的分离编译，当工程很大时，编译时间不可小觑 ；无法处理异质对象集合

##### 动态多态

> 是指在程序运行时才能确定函数和实现的链接，此时才能确定调用哪个函数，运行期多态的实现依赖于**虚函数**（用'virtual'关键字修饰的函数）机制。将函数声明为虚函数会降低效率，一般函数在编译期其相对地址是确定的。
>
> * **重写**翻译自override，是指**派生类中**存在重新定义的函数。其**函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致**。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。**重写的基类中被重写的函数必须有virtual修饰。**
>
> * **虚函数表**：虚表指明了实际所应调用的函数基类有一个虚表，可以被子类继承，(当类中有虚函数时该类才会有虚表,该类的对象才有虚指针，子类继承时也会继承基类的虚表)，子类如果重写了基类的某虚函数，那么子类继承于基类的虚表中该虚函数的地址也会相应改变，指向子类自身的该虚函数实现，如果子类有自己的虚函数，那么子类的虚表中就会增加该项，编译器为每个类对象定义了一个**虚指针**，来定位虚表。**在构造函数中进行虚表的创建和虚指针的初始化**。

##### 静态多态

> 是在编译期就把函数链接起来，此时即可确定调用哪个函数或模板，静态多态是由**模板**和**重载**实现的，在**宏多态**中，是通过定义变量，编译时直接把变量替换，实现宏多态。
>
> * **重载**从overload翻译过来，是指同一可访问区内被声明的**几个具有不同参数列表（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。**
>   * *优点：** 带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的武器； 在编译期完成多态，提高运行期效率； 具有很强的适配性和松耦合性，（耦合性指的是两个功能模块之间的依赖关系）
>   * **缺点：** 程序可读性降低，代码调试带来困难；无法实现模板的分离编译，当工程很大时，编译时间不可小觑 ；无法处理异质对象集合

#### 隐藏，与重载、重写的区别

> **隐藏**是指**派生类的函数屏蔽了与其同名的基类函数**。注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。

##### 重载与重写的区别

> * 范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
> * 参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
> * virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。

##### **隐藏和重写，重载的区别**

> * 与重载范围不同：隐藏函数和被隐藏函数在不同类中。
> * 参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。

### 深拷贝浅拷贝

#### 浅拷贝

> 对于基本的数据类型和简单对象，他们之间的拷贝非常简单，就是按位复制内存，这种默认的拷贝行为就是浅拷贝，这和memcpy()函数的调用效果非常类似。

```c++
int a=10;
int b=a;
```

#### 深拷贝

> 将对象所持有的其他资源一并拷贝的行为叫做深拷贝，必须显示的定义拷贝构造函数才能达到深拷贝的目的。深拷贝会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来，这样能保证原有对象和新对象所持有的动态内存都是相互独立的，更改一个对象的数据不会影响另一个对象。
>
> 深拷贝的例子比比皆是，标准模板库中的string、vector、stack、map等都是必须使用深拷贝的。

#### 怎么判断是深拷贝还是浅拷贝

> * 当一个类拥有指针类型的成员变量时，那么绝大部份情况下就需要深拷贝。因为只有这样才能将指针指向的内容再复制一份出来，让原有对象和新对象相互独立，彼此不影响。
>
> * 如果创建对象时需要进行一些预处理工作，比如统计创建过的对象数目、记录对象创建的时间等，这时就必须使用深拷贝。

### C++ 11特性

> [C++11 特性相关知识](https://www.nowcoder.com/discuss/840768?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=D68F5CC4A5088E8311C5FF791A330F3B-1646540556641)

	## 容器



### **list、vector、map、set区别**

#### **list**

> 封装链表，以链表形式实现，不支持[]运算符。
>
> 对随机访问的速度很慢(需要遍历整个链表)，插入数据很快(不需要拷贝和移动数据，只需改变指针的指向)。
>
> 新添加的元素，list可以任意加入。
>
> * 使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。

#### **vector**

> 封装数组，使用连续内存存储，支持[]运算符。
>
> 对随机访问的速度很快，对头插元素速度很慢，尾插元素速度很快
>
> 新添加的元素，vector有一套算法。

#### **map**

> 采用平衡检索二叉树:红黑树
>
> 存储结构为键值对<key,value>
>
> * 使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。

#### **set**

> 采用平衡检索二叉树:红黑树
>
> set中不包含重复的数据
>
> * 使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。

#### **Hash_Map**

> 采用hash算法加快查找过程，但需要更多内存存放hash桶元素，是一种采用空间换取时间的策略。

#### **stack**

> stack堆栈容器，是一种“先进后出”的容器

参考：[c++容器list、vector、map、set区别与用法详解](https://www.jb51.net/article/187294.htm)

## 并发

### 进程

> 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

### 线程

> 线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。

### 协程

> 协程与子例程一样，协程（coroutine）也是一种程序组件。一个程序可以包含多个协程，可以对比与一个进程包含多个线程。
>
> 协程和线程区别：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。

### 程序与进程与线程的关系与区别

![这里写图片描述](/img/70.png)

> * 地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间;因此线程可以读写同样的数据结构和变量，便于线程之间的通信。相反，进程间通信（IPC）很困难且消耗更多资源。 
> * 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源。
> * 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元。
> * 二者均可并发执行。
> * 进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束。
> * 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。

参考：[进程、线程和协程的理解](https://www.cnblogs.com/guolei2570/p/8810536.html)

